### 用预处理指令#define 声明一个常数，用以表明 1 年中有多少秒（忽略闰年）

```
#define SECONDS_PER_YEAR (60*60*24*365)UL
```

- #define 语法的基本知识（例如：不能以分号结束，括号的使用）
- 预处理器将自动计算表达式的值
- 意识到这个表达式将一个 16 位机的整形数溢出，因此要用到长整形符号 L，告诉编译器这个常数是长整形数
- UL 表示无符号长整形数

### 写一个标准宏 MIN，这个宏输入两个参数并返回较小的一个

```
#define MIN(A,B) ( (A) <= (B) ? (A) : (B) )
```

- 三重运算符，有时候比 if-else 更简洁
- 宏里面的参数一定要用括号括起来
- 宏也有副作用，比如下面的代码会有什么后果？

```
least = MIN(*p++, b);
```

### sizeof 和 strlen 的区别

- sizeof 是运算符，在编译器预处理时即计算好了； 而 strlen 是函数，要在运行时才能计算
- sizeof 的参数可以是变量的类型，也可以是变量；而 strlen 只能以结尾为'\0'的字符串作参数
- sizeof 计算数据类型占内存的大小；strlen 计算字符串实际长度，不包括'\0'


### Heap 与 Stack 的差别

- Heap 是堆，Stack 是栈
- Stack 的空间由系统自动分配/释放，Heap 上的空间手动分配/释放
- Stack 空间有限，Heap 是很大的自由存储区，malloc 函数分配的内存空间即在堆上

```
int a = 0; //全局初始化区 
char *p1;//全局未初始化区 
void main(void)
{
  int b; //栈 
  char s[] = "abc"; //栈 
  char *p2; //栈 
  char *p3 = "123456"; //123456\0在常量区，p3在栈上
  static int c =0; //全局（静态）初始化区 
  p1 = (char *)malloc(10); //堆 
  p2 = (char *)malloc(20); //堆 
}
```

### 堆和栈的区别是

| 类别     |                                                                   栈                                                                   |                                                                   堆                                                                   |
| -------- | :------------------------------------------------------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------------------------------------------------------------: |
| 存储内容 |                       在函数调用时，栈中存放的是函数中（最底下是函数调用后的下一条指令）的各个参数（局部变量）。                       |                                  一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员分配。                                  |
| 管理方式 | 由系统自动分配并释放空间。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间，当对应的生存周期结束后栈空间被自动释放。 |                      需要程序员指定大小手动申请和手动释放，在 C 语言中使用 malloc 函数申请，使用 free 函数释放。                       |
| 大小     |                        获取空间较小。在 Windows 下一般大小是 1M 或 2M，当剩余栈空间不足时，分配失败 overflow。                         |                                           获得空间根据系统的有效虚拟内存有关，比较灵活、大。                                           |
| 碎片     |                                                        不会产生碎片，空间连续。                                                        |                                                  采用的是链表的存储方式，会产生碎片。                                                  |
| 生长方向 |                                             向低地址扩展的数据结构，是一块连续的内存区域。                                             | 向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表空闲内存地址来存储的，自然不连续，而链表的遍历方向是由低地址向高地址。 |
| 分配方式 |            有 2 种分配方式：静态分配和动态分配，静态由编译器完成，例如局部变量；动态由 malloc 函数实现，由编译器进行释放。             |                                                   都是动态分配的，没有静态分配的堆。                                                   |
| 分配效率 |                                               由系统自动分配，速度较快，但程序员无法控制                                               |                                         一般速度比较慢，而且容易产生内存碎片,不过用起来最方便                                          |

### 堆栈在哪些情况下会溢出

- 使用递归函数时，嵌套层数过多，栈消耗会比较大
- 数组越界访问
- 指针非法访问
- 函数定义了较大的数组

### 用变量 a 给出下面的定义

```
A.一个整型数？
int a;

B.一个指向整型数的指针？
int *a;

C.一个指向指针的的指针，它指向的指针是指向一个整型数？
int **a;

D.一个有10个整型数的数组？
int a[10];

E.一个有10个指针的数组，该指针是指向一个整型数的？
int *a[10];

F.一个指向有10个整型数数组的指针?
int (*a)[10];

G.一个指向函数的指针，该函数有一个整型参数并返回一个整型数?
int (*a)(int);

H.一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数?
int (*a[10])(int);
```

### 下面的中断服务程序有哪些问题

```
__interrupt double compute_area(double radius)
{
  double area = PI * radius * radius;
  printf("Area = %f\n", area);
  return area;
}
```

- 中断服务程序不可以返回值
- 中断服务程序不可以传入参数
- 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额外的寄存器入栈，有些处理器/编译器就是不允许在 ISR 中做浮点运算。此外，浮点运算耗时较长，不应该在中断里面执行
- printf()有可重入问题，而且执行时间较长，不适合在中断里面执行

### 关键字 static 的作用是什么

- 在函数体内，一个被声明为静态的变量在这一函数被调用过程中维持其值不变;
- 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的局部变量;
- 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。也就是说，这个函数被限制在声明它的模块的本地范围内使用;

### 关键字 const 有什么含意？下面的声明都是什么意思

```
const int a;
a是一个只读整型数

int const a;
a是一个只读整型数

const int *a;
a是一个指向只读整型数的指针（也就是说，整型数是不可修改的，但指针可以）

int * const a;
a是一个指向整型数的只读指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）

int const * a const;
a是一个指向只读整型数的只读指针（也就是说，指针指向的整型数 是不可修改的，同时指针也是不可修改的）
```

- const 意味着“只读”
- 为什么要如此看重关键字 const 呢：
  - 关键字 const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用 const 的程序员很少会留下的垃圾让别人来清理的。）
  - 通过给优化器一些附加的信息，使用关键字 const 也许能产生更紧凑的代码。
  - 合理地使用关键字 const 可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少 bug 的出现。

### 关键字 volatile 有什么含意

- 一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，程序在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份

- 哪些情况需要用到 volatile 呢：

  - 并行设备的硬件寄存器（如：状态寄存器）
  - 一个中断服务子程序中会访问到的非自动变量(非自动变量见下面描述)
  - 多线程应用中被几个任务共享的变量

- 什么是自动变量和非自动变量：

  - 自动变量：是在函数内部定义和使用的变量，它是局部变量
  - 非自动变量：有两种，一种是全局变量，一种是静态变量

- 更加深入的几个问题：

  - 一个参数既可以是 const 还可以是 volatile 吗？解释为什么。

    - 是的。一个例子是只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它是 const 因为程序不应该试图去修改它。

    ```
    #define GPIO (GPIO_Typedef *)0x48000000U

    typedef struct{
           volatile const uint32_t ISR;//interrupt status register
    } GPIO_Typedef
    ```

  - 一个指针可以是 volatile 吗？解释为什么。

    - 是的。尽管这并不很常见。一个例子是当一个中断服务子程序修改指向一个 buffer 的指针时。
      ```
      uint8_t * volatile pArray;
      ```

  - 下面的函数有什么错误：

    - 对 volatile 的使用出现了错误

      ```
      int square(volatile int *ptr)
      {
        return (*ptr) * (*ptr);
      }

      //这段代码的目的是用来返指针*ptr指向值的平方，
      //但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：

      int square(volatile int *ptr)
      {
        int a,b;
        a = *ptr;
        b = *ptr;
        return a * b;
      }

      //由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。
      //结果，这段代码可能返不是你所期望的平方值！正确的代码如下：

      long square(volatile int *ptr)
      {
        int a;
        a = *ptr;
        return a * a;
      }
      ```

### 下面函数有问题吗

```
int square(volatile int *ptr)
{
  return *ptr * *ptr;
}
```

正确写法如下：

```
long square(volatile int *ptr)
{
  int a;
  a = *ptr;
  return a * a;
}
```

### register 的含义

- 这个关键字请求编译器尽可能的将变量存在 CPU 内部寄存器中，而不是通过内存寻址访问，以提高效率。注意是尽可能，不是绝对,一个 CPU 的寄存器也就那么几个或几十个，如果定义了很多 register 变量，不可能把这些变量全部放入寄存器中

### 在某工程中，要求设置一绝对地址为 0x67a9 的整型变量的值为 0xaa66。编译器是一个纯粹的 ANSI 编译器。写代码去完成这一任务?

- 一种写法

```
int *p;
p = (int*)0x67a9;
*p = 0xaa66;
```

- 另外一种写法

```
*((int * const)(0x67a9)) = 0xaa55;
```

### 给定一个整型变量 a，写两段代码，第一个设置 a 的 bit 3，第二个清除 a 的 bit 3。在以上两个操作中，要保持其它位不变？

```
#define BIT3 (0x1 << 3)
static int a;
void set_bit3(void)
{
  a |= BIT3;
}
void clear_bit3(void)
{
  a &= ~BIT3;
}
```

### ARM 里的大端格式和小端格式分别是什么意思

当前的存储器，多以 byte 为访问的最小单元，当一个逻辑上的地址必须分割为物理上的若干单元时就存在了先放谁后放谁的问题, 于是端(endian)的问题应运而生了, 对于不同的存储方法, 就有大端(big-endian)和小端(little- endian)两个描述。

字节排序按分为大端和小端，概念如下:

- 大端(big endian): 低地址存放高有效字节
- 小端(little endian): 低字节存放低有效字节

现在主流的 CPU, intel 系列的是采用的 little endian 的格式存放数据，而 motorola 系列的 CPU 采用的是 big endian，ARM 则同时支持 big 和 little。
举个例子:

```
int a = 0x12345678;
```

a 是四字节的 int 类型变量，需要占四个字节空间，假设变量 a 的首地址是 0x2000,那么数据存储在地址中的格式如下：

|  地址  | 小端 | 大端 |
| :----: | :--: | :--: |
| 0x2000 | 0x78 | 0x12 |
| 0x2001 | 0x56 | 0x34 |
| 0x2002 | 0x34 | 0x56 |
| 0x2003 | 0x12 | 0x78 |
